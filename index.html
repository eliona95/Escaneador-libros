<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Esc√°ner Libros">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="Escanea ISBNs de libros y comp√°ralos con tu base de datos">
    
    <title>üìö Esc√°ner de Libros</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2@1.8.4/dist/quagga.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Iconos SVG
        const Camera = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>;
        const CheckCircle = ({ size = 24, className = "" }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>;
        const XCircle = ({ size = 24, className = "" }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>;
        const Clock = ({ size = 24, className = "" }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>;
        const FolderOpen = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>;
        const Download = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
        const Upload = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>;
        const Trash2 = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>;
        const BookOpen = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>;
        const AlertCircle = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>;

        const BookScannerApp = () => {
          const [database, setDatabase] = useState([]);
          const [scannedBooks, setScannedBooks] = useState([]);
          const [currentBook, setCurrentBook] = useState(null);
          const [loading, setLoading] = useState(false);
          const [view, setView] = useState('scanner');
          const [csvLoaded, setCsvLoaded] = useState(false);
          const [scanning, setScanning] = useState(false);
          const [lastScanned, setLastScanned] = useState('');
          
          const fileInputRef = useRef(null);
          const scannerRef = useRef(null);

          useEffect(() => {
            const savedDatabase = localStorage.getItem('bookDatabase');
            const savedScanned = localStorage.getItem('scannedBooks');
            
            if (savedDatabase) {
              setDatabase(JSON.parse(savedDatabase));
              setCsvLoaded(true);
            }
            if (savedScanned) {
              setScannedBooks(JSON.parse(savedScanned));
            }

            // Registrar Service Worker
            if ('serviceWorker' in navigator) {
              navigator.serviceWorker.register('./sw.js').then(() => {
                console.log('Service Worker registrado');
              });
            }
          }, []);

          useEffect(() => {
            if (database.length > 0) {
              localStorage.setItem('bookDatabase', JSON.stringify(database));
            }
          }, [database]);

          useEffect(() => {
            if (scannedBooks.length > 0) {
              localStorage.setItem('scannedBooks', JSON.stringify(scannedBooks));
            }
          }, [scannedBooks]);

          useEffect(() => {
            return () => {
              if (scanning) {
                stopScanner();
              }
            };
          }, []);

          const handleFileUpload = (event) => {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => {
                const text = e.target.result;
                const lines = text.split('\n');
                const books = [];
                
                for (let i = 1; i < lines.length; i++) {
                  const line = lines[i].trim();
                  if (line) {
                    const parts = [];
                    let currentField = '';
                    let inQuotes = false;
                    
                    for (let j = 0; j < line.length; j++) {
                      const char = line[j];
                      
                      if (char === '"') {
                        inQuotes = !inQuotes;
                      } else if (char === ',' && !inQuotes) {
                        parts.push(currentField.trim());
                        currentField = '';
                      } else {
                        currentField += char;
                      }
                    }
                    parts.push(currentField.trim());
                    
                    if (parts.length >= 2) {
                      books.push({
                        author: parts[0] || '',
                        title: parts[1] || '',
                        publisher: parts[2] || '',
                        year: parts[3] || ''
                      });
                    }
                  }
                }
                
                setDatabase(books);
                setCsvLoaded(true);
                alert(`‚úÖ Base de datos cargada: ${books.length} libros`);
              };
              reader.readAsText(file);
            }
          };

          const normalizeText = (text) => {
            if (!text) return '';
            return text.toLowerCase()
              .normalize("NFD")
              .replace(/[\u0300-\u036f]/g, "")
              .replace(/[^\w\s]/g, '')
              .trim();
          };

          const calculateSimilarity = (str1, str2) => {
            const s1 = normalizeText(str1);
            const s2 = normalizeText(str2);
            
            if (s1 === s2) return 1;
            if (!s1 || !s2) return 0;
            
            if (s1.includes(s2) || s2.includes(s1)) return 0.8;
            
            const words1 = s1.split(/\s+/);
            const words2 = s2.split(/\s+/);
            
            let matches = 0;
            for (const word1 of words1) {
              for (const word2 of words2) {
                if (word1 === word2 || word1.includes(word2) || word2.includes(word1)) {
                  matches++;
                  break;
                }
              }
            }
            
            return matches / Math.max(words1.length, words2.length);
          };

          const findMatches = (bookInfo) => {
            const scannedTitle = normalizeText(bookInfo.title);
            const scannedAuthor = normalizeText(bookInfo.author);
            
            const exactMatch = database.find(book => {
              const dbTitle = normalizeText(book.title);
              const dbAuthor = normalizeText(book.author);
              return dbTitle === scannedTitle && dbAuthor === scannedAuthor;
            });

            if (exactMatch) {
              return { type: 'exact', matches: [exactMatch] };
            }

            const similarMatches = database.filter(book => {
              const titleSimilarity = calculateSimilarity(book.title, bookInfo.title);
              const authorSimilarity = calculateSimilarity(book.author, bookInfo.author);
              
              return (titleSimilarity > 0.7 && authorSimilarity > 0.4) ||
                     (titleSimilarity > 0.4 && authorSimilarity > 0.7);
            });

            similarMatches.sort((a, b) => {
              const simA = calculateSimilarity(a.title, bookInfo.title) + 
                           calculateSimilarity(a.author, bookInfo.author);
              const simB = calculateSimilarity(b.title, bookInfo.title) + 
                           calculateSimilarity(b.author, bookInfo.author);
              return simB - simA;
            });

            if (similarMatches.length > 0) {
              return { type: 'similar', matches: similarMatches.slice(0, 3) };
            }

            return { type: 'none', matches: [] };
          };

          const fetchBookInfo = async (isbn) => {
            setLoading(true);
            
            try {
              const googleResponse = await fetch(
                `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`
              );
              const googleData = await googleResponse.json();
              
              if (googleData.items && googleData.items.length > 0) {
                const book = googleData.items[0].volumeInfo;
                const bookInfo = {
                  isbn: isbn,
                  title: book.title || 'T√≠tulo desconocido',
                  author: book.authors ? book.authors.join(', ') : 'Autor desconocido',
                  publisher: book.publisher || '',
                  year: book.publishedDate ? book.publishedDate.split('-')[0] : '',
                  cover: book.imageLinks?.thumbnail || book.imageLinks?.smallThumbnail || '',
                  scannedAt: new Date().toISOString(),
                  folder: 'pending'
                };
                
                const matchResult = findMatches(bookInfo);
                bookInfo.matchType = matchResult.type;
                bookInfo.matches = matchResult.matches;
                
                setCurrentBook(bookInfo);
                setLoading(false);
                return bookInfo;
              }

              const openLibResponse = await fetch(
                `https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json&jscmd=data`
              );
              const openLibData = await openLibResponse.json();
              const bookKey = `ISBN:${isbn}`;
              
              if (openLibData[bookKey]) {
                const book = openLibData[bookKey];
                const bookInfo = {
                  isbn: isbn,
                  title: book.title || 'T√≠tulo desconocido',
                  author: book.authors ? book.authors.map(a => a.name).join(', ') : 'Autor desconocido',
                  publisher: book.publishers ? book.publishers[0].name : '',
                  year: book.publish_date || '',
                  cover: book.cover?.large || book.cover?.medium || book.cover?.small || '',
                  scannedAt: new Date().toISOString(),
                  folder: 'pending'
                };
                
                const matchResult = findMatches(bookInfo);
                bookInfo.matchType = matchResult.type;
                bookInfo.matches = matchResult.matches;
                
                setCurrentBook(bookInfo);
                setLoading(false);
                return bookInfo;
              }

              const bookInfo = {
                isbn: isbn,
                title: `Libro ISBN: ${isbn}`,
                author: 'Informaci√≥n no disponible',
                publisher: '',
                year: '',
                cover: '',
                scannedAt: new Date().toISOString(),
                folder: 'pending'
              };
              
              const matchResult = findMatches(bookInfo);
              bookInfo.matchType = matchResult.type;
              bookInfo.matches = matchResult.matches;
              
              setCurrentBook(bookInfo);
              setLoading(false);
              return bookInfo;
              
            } catch (error) {
              console.error('Error fetching book info:', error);
              const bookInfo = {
                isbn: isbn,
                title: `Libro ISBN: ${isbn}`,
                author: 'Error al obtener informaci√≥n',
                publisher: '',
                year: '',
                cover: '',
                scannedAt: new Date().toISOString(),
                folder: 'pending',
                matchType: 'none',
                matches: []
              };
              setCurrentBook(bookInfo);
              setLoading(false);
              return bookInfo;
            }
          };

          const startScanner = () => {
            if (!csvLoaded) {
              alert('‚ö†Ô∏è Primero debes cargar tu base de datos CSV');
              return;
            }

            setScanning(true);
            
            setTimeout(() => {
              if (window.Quagga && scannerRef.current) {
                window.Quagga.init({
                  inputStream: {
                    name: "Live",
                    type: "LiveStream",
                    target: scannerRef.current,
                    constraints: {
                      width: { ideal: 1280 },
                      height: { ideal: 720 },
                      facingMode: "environment"
                    },
                    area: {
                      top: "20%",
                      right: "10%",
                      left: "10%",
                      bottom: "20%"
                    }
                  },
                  locator: {
                    patchSize: "medium",
                    halfSample: true
                  },
                  numOfWorkers: navigator.hardwareConcurrency || 4,
                  decoder: {
                    readers: [
                      "ean_reader",
                      "ean_8_reader",
                      "code_128_reader",
                      "upc_reader",
                      "upc_e_reader"
                    ]
                  },
                  locate: true,
                  frequency: 10
                }, (err) => {
                  if (err) {
                    console.error(err);
                    alert('‚ùå Error al acceder a la c√°mara. Aseg√∫rate de dar permisos.');
                    setScanning(false);
                    return;
                  }
                  window.Quagga.start();
                });

                window.Quagga.onDetected((result) => {
                  if (result && result.codeResult && result.codeResult.code) {
                    const code = result.codeResult.code;
                    
                    if (/^\d{10}(\d{3})?$/.test(code) && code !== lastScanned) {
                      setLastScanned(code);
                      
                      try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.value = 800;
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                      } catch (e) {
                        console.log('Audio no disponible');
                      }
                      
                      if (navigator.vibrate) {
                        navigator.vibrate(100);
                      }
                      
                      stopScanner();
                      fetchBookInfo(code);
                    }
                  }
                });
              }
            }, 100);
          };

          const stopScanner = () => {
            if (window.Quagga) {
              window.Quagga.stop();
            }
            setScanning(false);
            setLastScanned('');
          };

          const archiveBook = (folder) => {
            if (!currentBook) return;

            const isDuplicate = scannedBooks.find(book => 
              book.isbn === currentBook.isbn
            );

            if (isDuplicate) {
              alert('‚ö†Ô∏è Este libro ya fue escaneado y archivado anteriormente');
              return;
            }

            const updatedBook = { ...currentBook, folder: folder };
            setScannedBooks(prev => [...prev, updatedBook]);
            
            const folderName = folder === 'match' ? 'COINCIDENCIAS ‚úÖ' : 'NO COINCIDENCIAS ‚ùå';
            alert(`üìÇ Libro archivado en:\n${folderName}`);
            
            setCurrentBook(null);
          };

          const exportToCSV = () => {
            const headers = ['Carpeta', 'Estado', 'T√≠tulo', 'Autor', 'ISBN', 'Editorial', 'A√±o'];
            const rows = scannedBooks.map(book => {
              const folder = book.folder === 'match' ? 'üìÇ COINCIDENCIAS' : 
                             book.folder === 'nomatch' ? 'üìÇ NO COINCIDENCIAS' : '‚è≥ PENDIENTE';
              const status = book.folder === 'match' ? '‚úÖ En tu base de datos' : 
                             book.folder === 'nomatch' ? '‚ùå NO en tu base de datos' : '‚è≥ Sin archivar';
              
              return [
                folder,
                status,
                book.title,
                book.author,
                book.isbn,
                book.publisher,
                book.year
              ].map(field => `"${field}"`).join(',');
            });

            const csv = [headers.join(','), ...rows].join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `libros_escaneados_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();

            const matches = scannedBooks.filter(b => b.folder === 'match').length;
            const noMatches = scannedBooks.filter(b => b.folder === 'nomatch').length;
            const pending = scannedBooks.filter(b => b.folder === 'pending').length;

            alert(`üìä Resumen de Exportaci√≥n\n\n‚úÖ Coincidencias: ${matches}\n‚ùå NO Coincidencias: ${noMatches}\n‚è≥ Pendientes: ${pending}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìö Total escaneados: ${scannedBooks.length}\n\n‚úÖ Archivo CSV descargado`);
          };

          const ResultView = () => {
            if (!currentBook) return null;

            return (
              <div className="result-container">
                <div className={`match-header ${currentBook.matchType === 'exact' ? 'exact-match' : currentBook.matchType === 'similar' ? 'similar-match' : 'no-match'}`}>
                  {currentBook.matchType === 'exact' && (
                    <>
                      <CheckCircle size={32} />
                      <h2>COINCIDENCIA EXACTA</h2>
                    </>
                  )}
                  {currentBook.matchType === 'similar' && (
                    <>
                      <AlertCircle size={32} />
                      <h2>POSIBLES COINCIDENCIAS</h2>
                    </>
                  )}
                  {currentBook.matchType === 'none' && (
                    <>
                      <XCircle size={32} />
                      <h2>NO ENCONTRADO</h2>
                    </>
                  )}
                </div>

                <div className="book-info-card">
                  {currentBook.cover ? (
                    <img src={currentBook.cover} alt={currentBook.title} className="book-cover" />
                  ) : (
                    <div className="book-cover-placeholder">
                      <BookOpen size={48} />
                    </div>
                  )}
                  
                  <div className="book-details">
                    <h3>{currentBook.title}</h3>
                    <p className="author">{currentBook.author}</p>
                    {currentBook.publisher && <p className="publisher">{currentBook.publisher}, {currentBook.year}</p>}
                    <p className="isbn">ISBN: {currentBook.isbn}</p>
                  </div>
                </div>

                {currentBook.matchType === 'exact' && (
                  <div className="match-details">
                    <div className="match-banner">
                      ‚ú® Coincidencia exacta en tu base de datos:
                    </div>
                    {currentBook.matches.map((match, idx) => (
                      <div key={idx} className="match-item">
                        <p><strong>üìñ {match.title}</strong></p>
                        <p>üë§ {match.author}</p>
                        <p>üè¢ {match.publisher}{match.year ? `, ${match.year}` : ''}</p>
                      </div>
                    ))}
                  </div>
                )}

                {currentBook.matchType === 'similar' && (
                  <div className="match-details">
                    <div className="match-banner warning">
                      ‚ö†Ô∏è Encontramos coincidencias similares en tu base de datos:
                    </div>
                    {currentBook.matches.map((match, idx) => (
                      <div key={idx} className="match-item">
                        <p><strong>üìñ {match.title}</strong></p>
                        <p>üë§ {match.author}</p>
                        <p>üè¢ {match.publisher}{match.year ? `, ${match.year}` : ''}</p>
                      </div>
                    ))}
                    <p className="match-question">¬øEs alguno de estos el mismo libro?</p>
                  </div>
                )}

                {currentBook.matchType === 'none' && (
                  <div className="match-details">
                    <div className="match-banner error">
                      ‚ùå Este libro NO est√° en tu base de datos
                    </div>
                    <p>Debes a√±adirlo a tu CSV</p>
                  </div>
                )}

                <div className="action-buttons">
                  <button 
                    className="btn-archive match"
                    onClick={() => archiveBook('match')}
                  >
                    üìÇ Coincide - Archivar
                  </button>
                  <button 
                    className="btn-archive nomatch"
                    onClick={() => archiveBook('nomatch')}
                  >
                    ‚ùå No Coincide - Archivar
                  </button>
                  <button 
                    className="btn-next"
                    onClick={() => setCurrentBook(null)}
                  >
                    ‚è≠Ô∏è Siguiente
                  </button>
                </div>
              </div>
            );
          };

          const HistoryView = () => {
            const groupedBooks = {
              match: scannedBooks.filter(b => b.folder === 'match'),
              nomatch: scannedBooks.filter(b => b.folder === 'nomatch'),
              pending: scannedBooks.filter(b => b.folder === 'pending')
            };

            return (
              <div className="history-container">
                <h2>üìã Historial de Escaneos</h2>
                
                <div className="stats">
                  <div className="stat-item match">
                    <CheckCircle size={24} />
                    <span>{groupedBooks.match.length} Coincidencias</span>
                  </div>
                  <div className="stat-item nomatch">
                    <XCircle size={24} />
                    <span>{groupedBooks.nomatch.length} No Coincidencias</span>
                  </div>
                  <div className="stat-item pending">
                    <Clock size={24} />
                    <span>{groupedBooks.pending.length} Pendientes</span>
                  </div>
                </div>

                {scannedBooks.length === 0 ? (
                  <div className="empty-state">
                    <BookOpen size={64} />
                    <p>No hay libros escaneados a√∫n</p>
                  </div>
                ) : (
                  <div className="history-list">
                    {[...scannedBooks].reverse().map((book, idx) => (
                      <div key={idx} className={`history-item ${book.folder}`}>
                        <div className="history-cover">
                          {book.cover ? (
                            <img src={book.cover} alt={book.title} />
                          ) : (
                            <BookOpen size={24} />
                          )}
                        </div>
                        <div className="history-info">
                          <div className="history-header">
                            {book.folder === 'match' && <CheckCircle size={20} className="icon-match" />}
                            {book.folder === 'nomatch' && <XCircle size={20} className="icon-nomatch" />}
                            {book.folder === 'pending' && <Clock size={20} className="icon-pending" />}
                            <h4>{book.title}</h4>
                          </div>
                          <p className="history-author">{book.author}</p>
                          <p className="history-isbn">ISBN: {book.isbn}</p>
                          <p className="history-folder">
                            üìÇ {book.folder === 'match' ? 'Coincide' : book.folder === 'nomatch' ? 'No Coincide' : 'Pendiente'}
                          </p>
                        </div>
                      </div>
                    ))}
                  </div>
                )}

                {scannedBooks.length > 0 && (
                  <div className="action-buttons">
                    <button className="btn-export" onClick={exportToCSV}>
                      <Download size={20} />
                      üíæ Exportar Resultados
                    </button>
                    <button 
                      className="btn-clear" 
                      onClick={() => {
                        if (window.confirm('¬øSeguro que quieres borrar todo el historial?')) {
                          setScannedBooks([]);
                          localStorage.removeItem('scannedBooks');
                        }
                      }}
                    >
                      <Trash2 size={20} />
                      Limpiar Historial
                    </button>
                  </div>
                )}
              </div>
            );
          };

          const ScannerView = () => (
            <div className="scanner-container">
              {!csvLoaded ? (
                <div className="setup-container">
                  <div className="setup-card">
                    <Upload size={64} />
                    <h2>üìö Cargar Base de Datos</h2>
                    <p>Primero debes cargar tu archivo CSV con la base de datos de libros</p>
                    <p className="setup-hint">Formato: Autor/a, T√≠tulo, Editorial, A√±o</p>
                    <input
                      type="file"
                      ref={fileInputRef}
                      accept=".csv"
                      onChange={handleFileUpload}
                      style={{ display: 'none' }}
                    />
                    <button 
                      className="btn-upload"
                      onClick={() => fileInputRef.current.click()}
                    >
                      <Upload size={20} />
                      Seleccionar archivo CSV
                    </button>
                  </div>
                </div>
              ) : (
                <>
                  <div className="database-info">
                    <CheckCircle size={20} />
                    <span>Base de datos cargada: {database.length} libros</span>
                  </div>

                  {scanning ? (
                    <div className="camera-container">
                      <div className="camera-header">
                        <h3>üì∏ Apunta al c√≥digo ISBN</h3>
                        <button className="btn-stop-scan" onClick={stopScanner}>
                          ‚úï Cerrar
                        </button>
                      </div>
                      <div id="scanner" ref={scannerRef} className="scanner-video"></div>
                      <div className="scanner-overlay">
                        <div className="scanner-frame"></div>
                      </div>
                      <p className="scanner-instruction">Centra el c√≥digo de barras en el recuadro</p>
                    </div>
                  ) : loading ? (
                    <div className="loading">
                      <div className="spinner"></div>
                      <p>Buscando informaci√≥n del libro...</p>
                    </div>
                  ) : currentBook ? (
                    <ResultView />
                  ) : (
                    <div className="scan-ready">
                      <div className="scan-icon-large">
                        <Camera size={80} />
                      </div>
                      <h2>Listo para Escanear</h2>
                      <p>Toca el bot√≥n para activar la c√°mara y escanear el c√≥digo ISBN de tu libro</p>
                      
                      <button className="btn-camera-large" onClick={startScanner}>
                        <Camera size={28} />
                        üì∏ Activar C√°mara
                      </button>

                      <div className="scan-tips">
                        <h3>üí° Consejos para escanear:</h3>
                        <ul>
                          <li>‚úÖ Usa buena iluminaci√≥n</li>
                          <li>‚úÖ Mant√©n el m√≥vil estable</li>
                          <li>‚úÖ Centra el c√≥digo en el recuadro</li>
                          <li>‚úÖ Mant√©n distancia de 10-15cm</li>
                        </ul>
                      </div>
                    </div>
                  )}
                </>
              )}
            </div>
          );

          return (
            <div className="app">
              <header className="header">
                <h1>
                  <BookOpen size={28} />
                  üìö Esc√°ner de Libros
                </h1>
              </header>

              <main className="main-content">
                {view === 'scanner' && <ScannerView />}
                {view === 'history' && <HistoryView />}
              </main>

              <nav className="nav-bar">
                <button 
                  className={`nav-item ${view === 'scanner' ? 'active' : ''}`}
                  onClick={() => {
                    if (scanning) stopScanner();
                    setView('scanner');
                  }}
                >
                  <Camera size={24} />
                  <span>Escanear</span>
                </button>
                <button 
                  className={`nav-item ${view === 'history' ? 'active' : ''}`}
                  onClick={() => {
                    if (scanning) stopScanner();
                    setView('history');
                  }}
                >
                  <FolderOpen size={24} />
                  <span>Historial</span>
                </button>
              </nav>
            </div>
          );
        };

        ReactDOM.render(<BookScannerApp />, document.getElementById('root'));
    </script>

    <link rel="stylesheet" href="styles.css">
</body>
</html>