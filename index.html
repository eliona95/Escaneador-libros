<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Esc√°ner Libros">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="Escanea ISBNs de libros y comp√°ralos con tu base de datos">
    
    <title>üìö Esc√°ner de Libros</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2@1.8.4/dist/quagga.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Iconos SVG
        const Camera = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>;
        const CheckCircle = ({ size = 24, className = "" }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>;
        const XCircle = ({ size = 24, className = "" }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>;
        const Clock = ({ size = 24, className = "" }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>;
        const FolderOpen = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>;
        const Download = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
        const Upload = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>;
        const Trash2 = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>;
        const BookOpen = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>;
        const AlertCircle = ({ size = 24 }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>;

        const BookScannerApp = () => {
          const [database, setDatabase] = useState([]);
          const [scannedBooks, setScannedBooks] = useState([]);
          const [currentBook, setCurrentBook] = useState(null);
          const [loading, setLoading] = useState(false);
          const [loadingMessage, setLoadingMessage] = useState('Buscando informaci√≥n...');
          const [view, setView] = useState('scanner');
          const [csvLoaded, setCsvLoaded] = useState(false);
          const [scanning, setScanning] = useState(false);
          const [lastScanned, setLastScanned] = useState('');
          const [debugMode, setDebugMode] = useState(false);
          
          const fileInputRef = useRef(null);
          const scannerRef = useRef(null);

          useEffect(() => {
            const savedDatabase = localStorage.getItem('bookDatabase');
            const savedScanned = localStorage.getItem('scannedBooks');
            
            if (savedDatabase) {
              try {
                const parsed = JSON.parse(savedDatabase);
                setDatabase(parsed);
                setCsvLoaded(true);
                console.log(`‚úÖ Base de datos cargada: ${parsed.length} libros`);
              } catch (e) {
                console.error('Error al cargar base de datos:', e);
              }
            }
            if (savedScanned) {
              try {
                setScannedBooks(JSON.parse(savedScanned));
              } catch (e) {
                console.error('Error al cargar historial:', e);
              }
            }

            // Registrar Service Worker
            if ('serviceWorker' in navigator) {
              navigator.serviceWorker.register('./sw.js').catch(() => {
                console.log('Service Worker no disponible');
              });
            }
          }, []);

          useEffect(() => {
            if (database.length > 0) {
              localStorage.setItem('bookDatabase', JSON.stringify(database));
            }
          }, [database]);

          useEffect(() => {
            if (scannedBooks.length > 0) {
              localStorage.setItem('scannedBooks', JSON.stringify(scannedBooks));
            }
          }, [scannedBooks]);

          useEffect(() => {
            return () => {
              if (scanning) {
                stopScanner();
              }
            };
          }, []);

          // Funci√≥n mejorada de carga de CSV
          const handleFileUpload = (event) => {
            const file = event.target.files[0];
            if (!file) {
              alert('‚ö†Ô∏è No se seleccion√≥ ning√∫n archivo');
              return;
            }

            if (!file.name.endsWith('.csv')) {
              alert('‚ö†Ô∏è Por favor selecciona un archivo CSV v√°lido');
              return;
            }

            console.log(`üìÑ Cargando archivo: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`);
            
            const reader = new FileReader();
            
            reader.onerror = () => {
              alert('‚ùå Error al leer el archivo. Verifica que sea un archivo CSV v√°lido.');
              console.error('Error en FileReader');
            };
            
            reader.onload = (e) => {
              try {
                const text = e.target.result;
                const lines = text.split('\n');
                
                if (lines.length < 2) {
                  alert('‚ö†Ô∏è El archivo CSV est√° vac√≠o o no tiene el formato correcto');
                  return;
                }
                
                console.log(`üìä Procesando ${lines.length} l√≠neas...`);
                const books = [];
                let errores = 0;
                
                // Saltar la primera l√≠nea (encabezados)
                for (let i = 1; i < lines.length; i++) {
                  const line = lines[i].trim();
                  if (!line) continue;
                  
                  try {
                    const parts = [];
                    let currentField = '';
                    let inQuotes = false;
                    
                    for (let j = 0; j < line.length; j++) {
                      const char = line[j];
                      
                      if (char === '"') {
                        inQuotes = !inQuotes;
                      } else if (char === ',' && !inQuotes) {
                        parts.push(currentField.trim());
                        currentField = '';
                      } else {
                        currentField += char;
                      }
                    }
                    parts.push(currentField.trim());
                    
                    if (parts.length >= 2) {
                      books.push({
                        title: parts[0] || '',
                        author: parts[1] || '',
                        publisher: parts[2] || '',
                        year: parts[3] || ''
                      });
                    } else {
                      errores++;
                    }
                  } catch (parseError) {
                    errores++;
                    console.warn(`L√≠nea ${i + 1} con error:`, line.substring(0, 50));
                  }
                }
                
                if (books.length === 0) {
                  alert('‚ùå No se pudo cargar ning√∫n libro del CSV. Verifica el formato:\ntitulo,autor,editorial,a√±o');
                  return;
                }
                
                setDatabase(books);
                setCsvLoaded(true);
                
                let mensaje = `‚úÖ Base de datos cargada: ${books.length} libros`;
                if (errores > 0) {
                  mensaje += `\n‚ö†Ô∏è ${errores} l√≠neas con errores fueron ignoradas`;
                }
                alert(mensaje);
                console.log(`‚úÖ ${books.length} libros cargados correctamente`);
                if (errores > 0) console.warn(`‚ö†Ô∏è ${errores} l√≠neas con errores`);
                
              } catch (error) {
                console.error('Error al procesar CSV:', error);
                alert('‚ùå Error al procesar el archivo CSV. Verifica que el formato sea correcto.');
              }
            };
            
            reader.readAsText(file, 'UTF-8');
          };

          // Normalizaci√≥n de texto mejorada
          const normalizeText = (text) => {
            if (!text) return '';
            return text.toLowerCase()
              .normalize("NFD")
              .replace(/[\u0300-\u036f]/g, "")
              .replace(/[^\w\s]/g, ' ')
              .replace(/\s+/g, ' ')
              .trim();
          };

          // Normalizaci√≥n de ISBN
          const normalizeISBN = (isbn) => {
            if (!isbn) return '';
            // Eliminar guiones, espacios y otros caracteres no num√©ricos
            let normalized = isbn.replace(/[^0-9X]/gi, '').toUpperCase();
            
            // Si es ISBN-10, convertir a ISBN-13
            if (normalized.length === 10) {
              // Remover el √∫ltimo d√≠gito (checksum)
              const isbn10 = normalized.slice(0, 9);
              // A√±adir prefijo 978
              normalized = '978' + isbn10;
              // Calcular nuevo checksum (simplificado)
              let sum = 0;
              for (let i = 0; i < 12; i++) {
                sum += parseInt(normalized[i]) * (i % 2 === 0 ? 1 : 3);
              }
              const checksum = (10 - (sum % 10)) % 10;
              normalized += checksum;
            }
            
            return normalized;
          };

          // C√°lculo de similitud mejorado
          const calculateSimilarity = (str1, str2) => {
            const s1 = normalizeText(str1);
            const s2 = normalizeText(str2);
            
            if (s1 === s2) return 1;
            if (!s1 || !s2) return 0;
            
            // Coincidencia completa de uno en otro
            if (s1.includes(s2) || s2.includes(s1)) return 0.95;
            
            const words1 = s1.split(/\s+/).filter(w => w.length > 0);
            const words2 = s2.split(/\s+/).filter(w => w.length > 0);
            
            if (words1.length === 0 || words2.length === 0) return 0;
            
            let matches = 0;
            const usedWords = new Set();
            
            for (const word1 of words1) {
              for (let i = 0; i < words2.length; i++) {
                if (usedWords.has(i)) continue;
                const word2 = words2[i];
                
                if (word1 === word2) {
                  matches += 1;
                  usedWords.add(i);
                  break;
                } else if (word1.length > 3 && word2.length > 3) {
                  if (word1.includes(word2) || word2.includes(word1)) {
                    matches += 0.8;
                    usedWords.add(i);
                    break;
                  }
                  // Similitud de Levenshtein simplificada para palabras largas
                  const maxLen = Math.max(word1.length, word2.length);
                  const minLen = Math.min(word1.length, word2.length);
                  if (minLen / maxLen > 0.7) {
                    let commonChars = 0;
                    for (let j = 0; j < minLen; j++) {
                      if (word1[j] === word2[j]) commonChars++;
                    }
                    if (commonChars / maxLen > 0.7) {
                      matches += 0.6;
                      usedWords.add(i);
                      break;
                    }
                  }
                }
              }
            }
            
            return matches / Math.max(words1.length, words2.length);
          };

          // Sistema de b√∫squeda mejorado con m√∫ltiples estrategias
          const findMatches = (bookInfo) => {
            if (!bookInfo || !bookInfo.title || database.length === 0) {
              return { type: 'none', matches: [], debug: 'Sin informaci√≥n o base de datos vac√≠a' };
            }

            const scannedTitle = normalizeText(bookInfo.title);
            const scannedAuthor = normalizeText(bookInfo.author);
            
            console.log(`üîç Buscando: "${bookInfo.title}" por "${bookInfo.author}"`);
            
            // Estrategia 1: Coincidencia exacta (t√≠tulo Y autor)
            const exactMatch = database.find(book => {
              const dbTitle = normalizeText(book.title);
              const dbAuthor = normalizeText(book.author);
              return dbTitle === scannedTitle && dbAuthor === scannedAuthor;
            });

            if (exactMatch) {
              console.log('‚úÖ Coincidencia exacta encontrada');
              return { type: 'exact', matches: [exactMatch], debug: 'Coincidencia exacta: t√≠tulo + autor' };
            }

            // Estrategia 2: T√≠tulo casi perfecto (‚â•90%)
            const titleOnlyMatches = database.filter(book => {
              const titleSim = calculateSimilarity(book.title, bookInfo.title);
              return titleSim >= 0.90;
            });

            if (titleOnlyMatches.length > 0) {
              titleOnlyMatches.sort((a, b) => {
                const simA = calculateSimilarity(a.title, bookInfo.title) + 
                             (calculateSimilarity(a.author, bookInfo.author) * 0.2);
                const simB = calculateSimilarity(b.title, bookInfo.title) + 
                             (calculateSimilarity(b.author, bookInfo.author) * 0.2);
                return simB - simA;
              });
              console.log('‚úÖ Coincidencia por t√≠tulo casi perfecto (‚â•90%)');
              return { type: 'exact', matches: [titleOnlyMatches[0]], debug: 'T√≠tulo ‚â•90% similar' };
            }

            // Estrategia 3: T√≠tulo muy similar (‚â•80%)
            const veryGoodMatches = database.filter(book => {
              const titleSim = calculateSimilarity(book.title, bookInfo.title);
              return titleSim >= 0.80;
            });

            if (veryGoodMatches.length > 0) {
              veryGoodMatches.sort((a, b) => {
                const simA = (calculateSimilarity(a.title, bookInfo.title) * 0.7) + 
                             (calculateSimilarity(a.author, bookInfo.author) * 0.3);
                const simB = (calculateSimilarity(b.title, bookInfo.title) * 0.7) + 
                             (calculateSimilarity(b.author, bookInfo.author) * 0.3);
                return simB - simA;
              });
              
              const best = veryGoodMatches[0];
              const bestAuthorSim = calculateSimilarity(best.author, bookInfo.author);
              
              if (bestAuthorSim >= 0.6) {
                console.log('‚úÖ Coincidencia por t√≠tulo + autor (80%/60%)');
                return { type: 'exact', matches: [best], debug: 'T√≠tulo ‚â•80% + autor ‚â•60%' };
              }
              
              console.log('‚ö†Ô∏è Similares encontrados (t√≠tulo ‚â•80%)');
              return { type: 'similar', matches: veryGoodMatches.slice(0, 3), debug: 'T√≠tulo ‚â•80%' };
            }

            // Estrategia 4: B√∫squeda flexible (‚â•70% t√≠tulo O combinaci√≥n)
            const similarMatches = database.filter(book => {
              const titleSimilarity = calculateSimilarity(book.title, bookInfo.title);
              const authorSimilarity = calculateSimilarity(book.author, bookInfo.author);
              
              return titleSimilarity >= 0.70 || 
                     (titleSimilarity >= 0.60 && authorSimilarity >= 0.60);
            });

            if (similarMatches.length > 0) {
              similarMatches.sort((a, b) => {
                const simA = (calculateSimilarity(a.title, bookInfo.title) * 0.7) + 
                             (calculateSimilarity(a.author, bookInfo.author) * 0.3);
                const simB = (calculateSimilarity(b.title, bookInfo.title) * 0.7) + 
                             (calculateSimilarity(b.author, bookInfo.author) * 0.3);
                return simB - simA;
              });
              
              console.log(`‚ö†Ô∏è ${similarMatches.length} similares encontrados (‚â•70%)` );
              return { type: 'similar', matches: similarMatches.slice(0, 3), debug: 'Similitud flexible' };
            }

            // Estrategia 5: B√∫squeda por palabras clave importantes
            const titleWords = scannedTitle.split(/\s+/).filter(w => w.length > 3);
            if (titleWords.length >= 2) {
              const keywordMatches = database.filter(book => {
                const dbTitle = normalizeText(book.title);
                let matchCount = 0;
                for (const word of titleWords) {
                  if (dbTitle.includes(word)) matchCount++;
                }
                return matchCount >= Math.max(2, Math.ceil(titleWords.length * 0.6));
              });

              if (keywordMatches.length > 0) {
                keywordMatches.sort((a, b) => {
                  const simA = calculateSimilarity(a.title, bookInfo.title);
                  const simB = calculateSimilarity(b.title, bookInfo.title);
                  return simB - simA;
                });
                console.log(`‚ö†Ô∏è ${keywordMatches.length} coincidencias por palabras clave`);
                return { type: 'similar', matches: keywordMatches.slice(0, 3), debug: 'Palabras clave' };
              }
            }

            console.log('‚ùå No se encontraron coincidencias');
            return { type: 'none', matches: [], debug: 'Sin coincidencias en ninguna estrategia' };
          };

          // B√∫squeda MEJORADA en APIs externas
          const fetchBookInfo = async (isbn) => {
            setLoading(true);
            setLoadingMessage('Buscando en Google Books...');
            
            const normalizedISBN = normalizeISBN(isbn);
            console.log(`üìñ Buscando ISBN: ${isbn} (normalizado: ${normalizedISBN})`);
            
            try {
              // Intento 1: Google Books API con ISBN normalizado
              try {
                setLoadingMessage('Consultando Google Books...');
                const googleResponse = await fetch(
                  `https://www.googleapis.com/books/v1/volumes?q=isbn:${normalizedISBN}`,
                  { timeout: 10000 }
                );
                
                if (googleResponse.ok) {
                  const googleData = await googleResponse.json();
                  
                  if (googleData.items && googleData.items.length > 0) {
                    const book = googleData.items[0].volumeInfo;
                    console.log('‚úÖ Encontrado en Google Books:', book.title);
                    
                    const bookInfo = {
                      isbn: isbn,
                      title: book.title || 'T√≠tulo desconocido',
                      author: book.authors ? book.authors.join(', ') : '',
                      publisher: book.publisher || '',
                      year: book.publishedDate ? book.publishedDate.split('-')[0] : '',
                      cover: book.imageLinks?.thumbnail?.replace('http:', 'https:') || 
                             book.imageLinks?.smallThumbnail?.replace('http:', 'https:') || '',
                      scannedAt: new Date().toISOString(),
                      folder: 'pending',
                      source: 'Google Books'
                    };
                    
                    // Si no hay autor, intentar otros m√©todos
                    if (!bookInfo.author || bookInfo.author === '') {
                      console.log('‚ö†Ô∏è Sin autor en Google Books, intentando Open Library...');
                      try {
                        const olData = await fetchOpenLibrary(normalizedISBN);
                        if (olData && olData.author) {
                          bookInfo.author = olData.author;
                          console.log('‚úÖ Autor encontrado en Open Library:', olData.author);
                        }
                      } catch (e) {
                        console.log('‚ùå Open Library fallido');
                      }
                    }
                    
                    const matchResult = findMatches(bookInfo);
                    bookInfo.matchType = matchResult.type;
                    bookInfo.matches = matchResult.matches;
                    bookInfo.debugInfo = matchResult.debug;
                    
                    setCurrentBook(bookInfo);
                    setLoading(false);
                    return bookInfo;
                  }
                }
              } catch (googleError) {
                console.warn('Google Books fall√≥:', googleError.message);
              }

              // Intento 2: Open Library API
              setLoadingMessage('Consultando Open Library...');
              const olData = await fetchOpenLibrary(normalizedISBN);
              if (olData) {
                console.log('‚úÖ Encontrado en Open Library:', olData.title);
                const matchResult = findMatches(olData);
                olData.matchType = matchResult.type;
                olData.matches = matchResult.matches;
                olData.debugInfo = matchResult.debug;
                
                setCurrentBook(olData);
                setLoading(false);
                return olData;
              }

              // Intento 3: Buscar con ISBN original (sin normalizar)
              if (isbn !== normalizedISBN) {
                console.log('Intentando con ISBN original...');
                setLoadingMessage('Reintentando con ISBN original...');
                
                try {
                  const googleRetry = await fetch(
                    `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`
                  );
                  
                  if (googleRetry.ok) {
                    const data = await googleRetry.json();
                    if (data.items && data.items.length > 0) {
                      const book = data.items[0].volumeInfo;
                      console.log('‚úÖ Encontrado con ISBN original:', book.title);
                      
                      const bookInfo = {
                        isbn: isbn,
                        title: book.title || 'T√≠tulo desconocido',
                        author: book.authors ? book.authors.join(', ') : 'Autor no disponible',
                        publisher: book.publisher || '',
                        year: book.publishedDate ? book.publishedDate.split('-')[0] : '',
                        cover: book.imageLinks?.thumbnail?.replace('http:', 'https:') || '',
                        scannedAt: new Date().toISOString(),
                        folder: 'pending',
                        source: 'Google Books (ISBN original)'
                      };
                      
                      const matchResult = findMatches(bookInfo);
                      bookInfo.matchType = matchResult.type;
                      bookInfo.matches = matchResult.matches;
                      bookInfo.debugInfo = matchResult.debug;
                      
                      setCurrentBook(bookInfo);
                      setLoading(false);
                      return bookInfo;
                    }
                  }
                } catch (e) {
                  console.log('Reintento con ISBN original fall√≥');
                }
              }

              // Si todo falla, crear entrada con ISBN
              console.log('‚ùå No encontrado en ninguna API');
              setLoadingMessage('No encontrado en bases de datos...');
              
              const bookInfo = {
                isbn: isbn,
                title: `ISBN: ${isbn}`,
                author: 'No disponible en bases de datos',
                publisher: '',
                year: '',
                cover: '',
                scannedAt: new Date().toISOString(),
                folder: 'pending',
                source: 'Manual',
                notFound: true
              };
              
              // A√∫n as√≠ intentamos buscar en nuestra BD
              const matchResult = findMatches(bookInfo);
              bookInfo.matchType = matchResult.type;
              bookInfo.matches = matchResult.matches;
              bookInfo.debugInfo = matchResult.debug || 'No encontrado en APIs externas';
              
              setCurrentBook(bookInfo);
              setLoading(false);
              return bookInfo;
              
            } catch (error) {
              console.error('‚ùå Error general en fetchBookInfo:', error);
              const bookInfo = {
                isbn: isbn,
                title: `ISBN: ${isbn}`,
                author: 'Error al obtener informaci√≥n',
                publisher: '',
                year: '',
                cover: '',
                scannedAt: new Date().toISOString(),
                folder: 'pending',
                matchType: 'none',
                matches: [],
                source: 'Error',
                error: true
              };
              setCurrentBook(bookInfo);
              setLoading(false);
              return bookInfo;
            }
          };

          // Funci√≥n auxiliar para Open Library
          const fetchOpenLibrary = async (isbn) => {
            try {
              const response = await fetch(
                `https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json&jscmd=data`,
                { timeout: 10000 }
              );
              
              if (!response.ok) return null;
              
              const data = await response.json();
              const bookKey = `ISBN:${isbn}`;
              
              if (data[bookKey]) {
                const book = data[bookKey];
                return {
                  isbn: isbn,
                  title: book.title || 'T√≠tulo desconocido',
                  author: book.authors ? book.authors.map(a => a.name).join(', ') : '',
                  publisher: book.publishers ? book.publishers.map(p => p.name).join(', ') : '',
                  year: book.publish_date || '',
                  cover: book.cover?.large?.replace('http:', 'https:') || 
                         book.cover?.medium?.replace('http:', 'https:') || 
                         book.cover?.small?.replace('http:', 'https:') || '',
                  scannedAt: new Date().toISOString(),
                  folder: 'pending',
                  source: 'Open Library'
                };
              }
            } catch (error) {
              console.warn('Open Library error:', error.message);
            }
            return null;
          };

          const startScanner = () => {
            if (!csvLoaded) {
              alert('‚ö†Ô∏è Primero debes cargar tu base de datos CSV');
              return;
            }

            setScanning(true);
            
            setTimeout(() => {
              if (window.Quagga && scannerRef.current) {
                window.Quagga.init({
                  inputStream: {
                    name: "Live",
                    type: "LiveStream",
                    target: scannerRef.current,
                    constraints: {
                      width: { ideal: 1280 },
                      height: { ideal: 720 },
                      facingMode: "environment"
                    },
                    area: {
                      top: "15%",
                      right: "10%",
                      left: "10%",
                      bottom: "15%"
                    }
                  },
                  locator: {
                    patchSize: "medium",
                    halfSample: true
                  },
                  numOfWorkers: navigator.hardwareConcurrency || 4,
                  decoder: {
                    readers: [
                      "ean_reader",
                      "ean_8_reader",
                      "code_128_reader",
                      "upc_reader",
                      "upc_e_reader"
                    ]
                  },
                  locate: true,
                  frequency: 10
                }, (err) => {
                  if (err) {
                    console.error('Error Quagga:', err);
                    alert('‚ùå Error al acceder a la c√°mara. Aseg√∫rate de dar permisos.');
                    setScanning(false);
                    return;
                  }
                  console.log('‚úÖ Esc√°ner iniciado');
                  window.Quagga.start();
                });

                window.Quagga.onDetected((result) => {
                  if (result && result.codeResult && result.codeResult.code) {
                    const code = result.codeResult.code;
                    
                    // Validar ISBN: 10 o 13 d√≠gitos
                    if (/^\d{10}(\d{3})?$/.test(code) && code !== lastScanned) {
                      console.log(`üì± C√≥digo escaneado: ${code}`);
                      setLastScanned(code);
                      
                      // Sonido de confirmaci√≥n
                      try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.value = 800;
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                      } catch (e) {
                        console.log('Audio no disponible');
                      }
                      
                      stopScanner();
                      fetchBookInfo(code);
                      
                      setTimeout(() => {
                        setLastScanned('');
                      }, 3000);
                    }
                  }
                });
              }
            }, 100);
          };

          const stopScanner = () => {
            if (window.Quagga) {
              window.Quagga.stop();
              console.log('‚èπÔ∏è Esc√°ner detenido');
            }
            setScanning(false);
          };

          const archiveBook = (folder) => {
            if (currentBook) {
              const updated = { ...currentBook, folder: folder };
              setScannedBooks(prev => [...prev, updated]);
              setCurrentBook(null);
              console.log(`üìÇ Libro archivado en: ${folder}`);
            }
          };

          const exportToCSV = () => {
            if (scannedBooks.length === 0) {
              alert('‚ö†Ô∏è No hay libros escaneados para exportar');
              return;
            }

            const headers = 'ISBN,T√≠tulo,Autor,Editorial,A√±o,Estado,Fecha\n';
            const rows = scannedBooks.map(book => {
              const estado = book.folder === 'match' ? 'Coincide' : 
                           book.folder === 'nomatch' ? 'No Coincide' : 'Pendiente';
              return `"${book.isbn}","${book.title}","${book.author}","${book.publisher}","${book.year}","${estado}","${new Date(book.scannedAt).toLocaleDateString()}"`;
            }).join('\n');

            const csv = headers + rows;
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `escaneo_libros_${new Date().toISOString().slice(0, 10)}.csv`;
            link.click();
            console.log(`üì§ Exportados ${scannedBooks.length} libros`);
          };

          const ResultView = () => {
            if (!currentBook) return null;

            return (
              <div className="result-container">
                <div className={`match-header ${
                  currentBook.matchType === 'exact' ? 'exact-match' : 
                  currentBook.matchType === 'similar' ? 'similar-match' : 'no-match'
                }`}>
                  {currentBook.matchType === 'exact' && (
                    <><CheckCircle size={24} /><h2>‚úÖ ENCONTRADO</h2></>
                  )}
                  {currentBook.matchType === 'similar' && (
                    <><AlertCircle size={24} /><h2>‚ö†Ô∏è SIMILARES</h2></>
                  )}
                  {currentBook.matchType === 'none' && (
                    <><XCircle size={24} /><h2>‚ùå NO ENCONTRADO</h2></>
                  )}
                </div>

                <div className="book-info-card">
                  {currentBook.cover ? (
                    <img src={currentBook.cover} alt="Portada" className="book-cover" />
                  ) : (
                    <div className="book-cover-placeholder">
                      <BookOpen size={48} />
                    </div>
                  )}
                  <div className="book-details">
                    <h3>{currentBook.title}</h3>
                    <p className="author">‚úçÔ∏è {currentBook.author || 'Autor desconocido'}</p>
                    {currentBook.publisher && (
                      <p className="publisher">üè¢ {currentBook.publisher}</p>
                    )}
                    {currentBook.year && (
                      <p className="publisher">üìÖ {currentBook.year}</p>
                    )}
                    <p className="isbn">üìñ ISBN: {currentBook.isbn}</p>
                    {currentBook.source && (
                      <p className="isbn" style={{marginTop: '8px', color: '#999'}}>
                        üîç Fuente: {currentBook.source}
                      </p>
                    )}
                  </div>
                </div>

                {currentBook.matches && currentBook.matches.length > 0 && (
                  <div className="match-details">
                    <div className={`match-banner ${currentBook.matchType === 'exact' ? '' : 'warning'}`}>
                      {currentBook.matchType === 'exact' ? 
                        '‚úÖ Este libro est√° en tu base de datos' : 
                        `‚ö†Ô∏è Encontrados ${currentBook.matches.length} libro(s) similar(es) en tu BD`}
                    </div>
                    {currentBook.matches.slice(0, 3).map((match, i) => (
                      <div key={i} className="match-item">
                        <p><strong>üìö {match.title}</strong></p>
                        <p>‚úçÔ∏è {match.author}</p>
                        {match.publisher && <p>üè¢ {match.publisher}</p>}
                        {match.year && <p>üìÖ {match.year}</p>}
                      </div>
                    ))}
                    {currentBook.matchType === 'similar' && (
                      <p className="match-question">¬øEs alguno de estos tu libro?</p>
                    )}
                  </div>
                )}

                {currentBook.matchType === 'none' && (
                  <div className="match-details">
                    <div className="match-banner error">
                      ‚ùå Este libro NO est√° en tu base de datos
                    </div>
                    <p style={{textAlign: 'center', margin: '12px 0', color: '#666'}}>
                      Debes a√±adirlo a tu CSV
                    </p>
                  </div>
                )}

                {debugMode && currentBook.debugInfo && (
                  <div style={{
                    background: '#f8f9fa',
                    padding: '12px',
                    borderRadius: '8px',
                    fontSize: '12px',
                    color: '#666',
                    marginTop: '12px'
                  }}>
                    üêõ Debug: {currentBook.debugInfo}
                  </div>
                )}

                <div className="action-buttons">
                  <button 
                    className="btn-archive match"
                    onClick={() => archiveBook('match')}
                  >
                    <CheckCircle size={20} />
                    üìÇ Coincide - Archivar
                  </button>
                  <button 
                    className="btn-archive nomatch"
                    onClick={() => archiveBook('nomatch')}
                  >
                    <XCircle size={20} />
                    üìÇ No Coincide - Archivar
                  </button>
                  <button 
                    className="btn-next"
                    onClick={() => {
                      setCurrentBook(null);
                      startScanner();
                    }}
                  >
                    <Camera size={20} />
                    üì∏ Siguiente
                  </button>
                </div>
              </div>
            );
          };

          const HistoryView = () => {
            const matchCount = scannedBooks.filter(b => b.folder === 'match').length;
            const nomatchCount = scannedBooks.filter(b => b.folder === 'nomatch').length;
            const pendingCount = scannedBooks.filter(b => b.folder === 'pending').length;

            return (
              <div className="history-container">
                <h2>
                  <Clock size={28} />
                  Historial de Escaneos
                </h2>

                <div className="stats">
                  <div className="stat-item match">
                    <CheckCircle size={32} />
                    <div style={{fontSize: '24px', fontWeight: 'bold'}}>{matchCount}</div>
                    <span>Coinciden</span>
                  </div>
                  <div className="stat-item nomatch">
                    <XCircle size={32} />
                    <div style={{fontSize: '24px', fontWeight: 'bold'}}>{nomatchCount}</div>
                    <span>No coinciden</span>
                  </div>
                  <div className="stat-item pending">
                    <Clock size={32} />
                    <div style={{fontSize: '24px', fontWeight: 'bold'}}>{pendingCount}</div>
                    <span>Pendientes</span>
                  </div>
                </div>

                {scannedBooks.length === 0 ? (
                  <div className="empty-state">
                    <BookOpen size={64} />
                    <p>No hay libros escaneados a√∫n</p>
                    <p style={{fontSize: '14px', marginTop: '8px'}}>
                      Ve a la pesta√±a Escanear para empezar
                    </p>
                  </div>
                ) : (
                  <div className="history-list">
                    {[...scannedBooks].reverse().map((book, i) => (
                      <div key={i} className={`history-item ${book.folder}`}>
                        <div className="history-cover">
                          {book.cover ? (
                            <img src={book.cover} alt={book.title} />
                          ) : (
                            <BookOpen size={24} />
                          )}
                        </div>
                        <div className="history-info">
                          <div className="history-header">
                            {book.folder === 'match' && <CheckCircle size={20} className="icon-match" />}
                            {book.folder === 'nomatch' && <XCircle size={20} className="icon-nomatch" />}
                            {book.folder === 'pending' && <Clock size={20} className="icon-pending" />}
                            <h4>{book.title}</h4>
                          </div>
                          <p className="history-author">{book.author}</p>
                          <p className="history-isbn">ISBN: {book.isbn}</p>
                          <p className="history-folder">
                            üìÇ {book.folder === 'match' ? 'Coincide' : book.folder === 'nomatch' ? 'No Coincide' : 'Pendiente'}
                          </p>
                        </div>
                      </div>
                    ))}
                  </div>
                )}

                {scannedBooks.length > 0 && (
                  <div className="action-buttons">
                    <button className="btn-export" onClick={exportToCSV}>
                      <Download size={20} />
                      üíæ Exportar Resultados
                    </button>
                    <button 
                      className="btn-clear" 
                      onClick={() => {
                        if (window.confirm('¬øSeguro que quieres borrar todo el historial?')) {
                          setScannedBooks([]);
                          localStorage.removeItem('scannedBooks');
                        }
                      }}
                    >
                      <Trash2 size={20} />
                      Limpiar Historial
                    </button>
                  </div>
                )}
              </div>
            );
          };

          const ScannerView = () => (
            <div className="scanner-container">
              {!csvLoaded ? (
                <div className="setup-container">
                  <div className="setup-card">
                    <Upload size={64} />
                    <h2>üìö Cargar Base de Datos</h2>
                    <p>Primero debes cargar tu archivo CSV con la base de datos de libros</p>
                    <p className="setup-hint">Formato: T√≠tulo, Autor, Editorial, A√±o</p>
                    <input
                      type="file"
                      ref={fileInputRef}
                      accept=".csv"
                      onChange={handleFileUpload}
                      style={{ display: 'none' }}
                    />
                    <button 
                      className="btn-upload"
                      onClick={() => fileInputRef.current?.click()}
                    >
                      <Upload size={20} />
                      Seleccionar archivo CSV
                    </button>
                  </div>
                </div>
              ) : (
                <>
                  <div className="database-info">
                    <div className="database-status">
                      <CheckCircle size={20} />
                      <span>Base de datos cargada: {database.length} libros</span>
                    </div>
                    <button 
                      className="btn-change-csv"
                      onClick={() => fileInputRef.current?.click()}
                      title="Cargar un nuevo archivo CSV"
                    >
                      <Upload size={18} />
                      Cambiar CSV
                    </button>
                    <input
                      type="file"
                      ref={fileInputRef}
                      accept=".csv"
                      onChange={handleFileUpload}
                      style={{ display: 'none' }}
                    />
                  </div>

                  {scanning ? (
                    <div className="camera-container">
                      <div className="camera-header">
                        <h3>üì∏ Apunta al c√≥digo ISBN</h3>
                        <button className="btn-stop-scan" onClick={stopScanner}>
                          ‚úï Cerrar
                        </button>
                      </div>
                      <div id="scanner" ref={scannerRef} className="scanner-video"></div>
                      <div className="scanner-overlay">
                        <div className="scanner-frame"></div>
                      </div>
                      <p className="scanner-instruction">Centra el c√≥digo de barras en el recuadro</p>
                    </div>
                  ) : loading ? (
                    <div className="loading">
                      <div className="spinner"></div>
                      <p>{loadingMessage}</p>
                      <p style={{fontSize: '14px', color: '#999', marginTop: '8px'}}>
                        Esto puede tardar unos segundos...
                      </p>
                    </div>
                  ) : currentBook ? (
                    <ResultView />
                  ) : (
                    <div className="scan-ready">
                      <div className="scan-icon-large">
                        <Camera size={80} />
                      </div>
                      <h2>Listo para Escanear</h2>
                      <p>Toca el bot√≥n para activar la c√°mara y escanear el c√≥digo ISBN de tu libro</p>
                      
                      <button className="btn-camera-large" onClick={startScanner}>
                        <Camera size={28} />
                        üì∏ Activar C√°mara
                      </button>

                      <div className="scan-tips">
                        <h3>üí° Consejos para escanear:</h3>
                        <ul>
                          <li>‚úÖ Usa buena iluminaci√≥n</li>
                          <li>‚úÖ Mant√©n el m√≥vil estable</li>
                          <li>‚úÖ Centra el c√≥digo en el recuadro</li>
                          <li>‚úÖ Mant√©n distancia de 10-15cm</li>
                        </ul>
                      </div>
                      
                      <button 
                        style={{
                          marginTop: '20px',
                          background: 'none',
                          border: 'none',
                          color: '#999',
                          fontSize: '12px',
                          cursor: 'pointer',
                          textDecoration: 'underline'
                        }}
                        onClick={() => setDebugMode(!debugMode)}
                      >
                        {debugMode ? 'üêõ Modo Debug ON' : 'Modo Debug'}
                      </button>
                    </div>
                  )}
                </>
              )}
            </div>
          );

          return (
            <div className="app">
              <header className="header">
                <h1>
                  <BookOpen size={28} />
                  üìö Esc√°ner de Libros
                </h1>
              </header>

              <main className="main-content">
                {view === 'scanner' && <ScannerView />}
                {view === 'history' && <HistoryView />}
              </main>

              <nav className="nav-bar">
                <button 
                  className={`nav-item ${view === 'scanner' ? 'active' : ''}`}
                  onClick={() => {
                    if (scanning) stopScanner();
                    setView('scanner');
                  }}
                >
                  <Camera size={24} />
                  <span>Escanear</span>
                </button>
                <button 
                  className={`nav-item ${view === 'history' ? 'active' : ''}`}
                  onClick={() => {
                    if (scanning) stopScanner();
                    setView('history');
                  }}
                >
                  <FolderOpen size={24} />
                  <span>Historial</span>
                </button>
              </nav>
            </div>
          );
        };

        ReactDOM.render(<BookScannerApp />, document.getElementById('root'));
    </script>

    <link rel="stylesheet" href="styles.css">
</body>
</html>

                  
